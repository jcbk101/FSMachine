local fsm = require("modules.fsm_engine")

local gravity = -2200
local jump_takeoff_speed = 1100
local max_speed = 500
local air_acceleration_factor = 0.8
local slopeDistance = 10


-------------------------------
--
-------------------------------
local function Perpendicular( vector, CW ) -- Default: Counter clock wise, CW == true and Clock wise
	if CW then
		return vmath.vector3(vector.y, -vector.x, vector.z)	
	else
		return vmath.vector3(-vector.y, vector.x, vector.z)	
	end
end

-------------------------------
--
-------------------------------
local function Angle( from, to )
	local dot = vmath.dot( vmath.normalize(from), vmath.normalize(to))
	local acos = math.acos( dot )
	local deg = math.deg(acos)

	return deg
end


-------------------------------
--
-------------------------------
local function CheckVertical(self, position)
	
	local to = vmath.vector3(position.x, (position.y - self.sprSize.y * .5) - slopeDistance , position.z)
	local ang = 0
	local hit = physics.raycast(position, to, { hash("ground") })

	if hit then		
		self.slopeNormalPerp = Perpendicular(hit.normal) -- Counter close wise
		self.slopeNormalPerp = vmath.normalize(self.slopeNormalPerp)
		ang = Angle( hit.normal, vmath.vector3(0, 1, 0))

		--msg.post("@render:", "draw_line", { start_point = to, end_point = position, color = vmath.vector4(0, 1, 1, 1) })
		msg.post("@render:", "draw_line", { start_point = hit.position, end_point = position, color = vmath.vector4(0, 1, 1, 1) })		
		msg.post("@render:", "draw_line", { start_point = hit.position, end_point = Perpendicular(position) , color = vmath.vector4(1, 1, 0, 1) })		
		
		-- if ang == 0 then
		-- 	self.isOnSlope = false
		-- else
		-- 	self.isOnSlope = true
		-- end		
	end

	return nil
end


---------------------------------
--
---------------------------------
local function SlopeCheck(self)

	local pos = go.get_position()

	--CheckHorizontal(self, pos)
	CheckVertical(self, pos)
end


---------------------------------
--
---------------------------------
local function getAnimationFrames(self, anim)

	local path = go.get("#sprite", "image")
	local ts_info = resource.get_atlas(path)

	for i = 1, #ts_info.animations do
		if hash(ts_info.animations[i].id) == anim then
			local frames, fps = go.get("#sprite", "frame_count"), ts_info.animations[i].fps
			local time = (1.0 / fps) * frames
			return { frames = frames, fps = fps, time = time }
		end
	end

	-- Default FPS
	local frames, fps = go.get("#sprite", "frame_count"), ts_info.animations[1].fps
	local time = (1.0 / 10.) * frames
	return { frames = frames, fps = fps, time = time }
end


------------------------------------
--
------------------------------------
local idleState = {
	init = function(self, parent)
		self.is_exiting = false
		--
		if go.get("#sprite", "animation") ~= hash("idle") then
			sprite.play_flipbook("#sprite", "idle")
		end
		parent.velocity.x = 0
	end,

	exit = function(self, parent)
		self.is_exiting = true
	end,

	input = function(self, parent, action_id, action)
		if not self.is_exiting then
			if (action_id == hash("left") or action_id == hash("right")) and (action.value and action.value > 0) then
				self:changeState(parent, "run")

			elseif action_id == hash("jump") and parent.states.jump:CanJump() then
				self:changeState(parent, "jump")
			end
		end		
	end,

	fixed_update = function(self,parent,dt)
		parent.velocity.y = parent.velocity.y + (gravity * dt)
		if parent.velocity.y < -1250.0 then 
			parent.velocity.y = -1250.0
		end

		if not parent.ground_contact then
			print("Fall")
			sprite.play_flipbook("#sprite", "fall")
			self:changeState(parent, "air")
			return
		end		

		local pos = go.get_position()
		pos = pos + parent.velocity * dt
		go.set_position(pos)

		if parent.ground_contact == true then
			parent.velocity.y = 0
		end				
		parent.ground_contact = false
		parent.correction.x, parent.correction.y, parent.correction.z = 0, 0, 0			
	end,

	-- Local variables
	is_exiting = false
}


------------------------------------
--
------------------------------------
local jumpState = {

	init = function(self, parent)
		if self.jumpAmount > 0 then
			parent.velocity.y = jump_takeoff_speed * (self.jumpAmount == 2 and 1 or 0.75)
			sprite.play_flipbook("#sprite", "jump" .. self.jumpAmount)
			--
			self.jumpAmount = self.jumpAmount - 1
			parent.ground_contact = false
			--
			--parent.key[hash("jump")] = nil  -- Clear jump key
			self:changeState(parent, "air")
		end
	end,

	-- Condition test
	CanJump = function(self)
		return (self.jumpAmount > 0 and true or false)
	end,

	-- Local variables
	jumpAmount = 2
}


------------------------------------
--
------------------------------------
local airState = {

	init = function(self, parent)
		self.is_exiting = false
	end,

	exit = function(self, parent)
		self.is_exiting = true
	end,

	input = function(self, parent, action_id, action)
		if not self.is_exiting then
			if (action_id == hash("left") or action_id == hash("right")) and (action.value and action.value ~= 0) then
				if action_id == hash("left") then
					sprite.set_hflip("#sprite", true)
					parent.velocity.x = -max_speed * air_acceleration_factor
				elseif action_id == hash("right") then
					sprite.set_hflip("#sprite", false)
					parent.velocity.x = max_speed * air_acceleration_factor				
				end
			else
				parent.velocity.x = 0
			end

			-- Test for air jump or abort jump
			if action_id == hash("jump") then
				if action and action.released then -- Abort the jump
					if parent.velocity.y > 0 then
						parent.velocity.y = parent.velocity.y * 0.5
					end
				elseif (action and action.pressed) and  parent.states.jump:CanJump() then
					parent.states.jump.jumpAmount = 1 -- Only allow air jump
					self:changeState(parent, "jump")
				end
			end
		end
	end,

	fixed_update = function(self, parent, dt)
		if not self.is_exiting then		
			-- Apply gravity
			if not parent.ground_contact then			
				parent.velocity.y = parent.velocity.y + (gravity * dt)
				if parent.velocity.y < -1250.0 then 
					parent.velocity.y = -1250.0
				end

				local pos = go.get_position()
				pos = (pos + parent.velocity * dt)
				go.set_position(pos)			
			else
				self:changeState(parent, "land")
			end
		end
	end,

	-- Local variables
	is_exiting = false
}


------------------------------------
--
------------------------------------
local landState = {

	init = function(self, parent)
		self.is_exiting = false
		parent.states.jump.jumpAmount = 2
		--		parent.states.jump.canDoubleJump = false
	end,

	exit = function(self, parent)
		self.is_exiting = true
	end,

	fixed_update = function(self, parent, dt)
		if not self.is_exiting then
			if parent.velocity.x ~= 0 then
				self:changeState(parent, "run")
			else
				parent.velocity.x = 0
				self:changeState(parent, "idle")
			end
		end
	end,

	-- Local variables	
	is_exiting = false
}


------------------------------------
--
------------------------------------
local runState = {

	init = function(self, parent)
		self.is_exiting = false
		self.falls = 0
		sprite.play_flipbook("#sprite", "run")
	end,

	exit = function(self, parent)
		self.is_exiting = true
	end,

	input = function(self, parent, action_id, action)
		if not self.is_exiting then			
			if action_id == hash("jump") and action.pressed and parent.states.jump:CanJump() then
				self:changeState(parent, "jump")

			elseif (action_id == hash("left") or action_id == hash("right")) then
				if (action.value and action.value == 0) then
					self:changeState(parent, "idle")
					parent.velocity.x = 0
				else
					if action_id == hash("left") and action.value and action.value > 0 then
						sprite.set_hflip("#sprite", true)
						parent.velocity.x = -max_speed
						parent.direction = -1
					elseif action_id == hash("right") and action.value and action.value > 0 then
						sprite.set_hflip("#sprite", false)
						parent.velocity.x = max_speed
						parent.direction = 1
					end					
				end
			end
		end			
	end,

	fixed_update = function(self, parent, dt)
		if not self.is_exiting then		

			parent.velocity.y = parent.velocity.y + (gravity * dt)
			if parent.velocity.y < -1250.0 then 
				parent.velocity.y = -1250.0
			end

			SlopeCheck(parent)

			if not parent.ground_contact then
				if   self.falls > 10 then					
					print("Fall")
					sprite.play_flipbook("#sprite", "fall")
					self:changeState(parent, "air")
					return
				else
					self.falls =  self.falls + 1
				end	
			else
				self.falls = 0
			end		

			local pos = go.get_position()

			if parent.isOnSlope then
				--				parent.velocity.x = (max_speed * -parent.direction) * parent.slopeNormalPerp.x
				parent.velocity.y = (max_speed * -parent.direction) * parent.slopeNormalPerp.y
				pos = (pos + parent.velocity * dt)
			else
				pos = (pos + parent.velocity * dt)
			end

			go.set_position(pos)

			-- 
			if parent.ground_contact == true then
				parent.velocity.y = 0
			end				
			parent.ground_contact = false
			parent.correction.x, parent.correction.y, parent.correction.z = 0, 0, 0			
		end
	end,

	-- Local variables
	is_exiting = false,
	falls = 0
}

------------------------------------
-- Init code 
------------------------------------
function init(self)
	msg.post(".", "acquire_input_focus")
	msg.post("/camera", "acquire_camera_focus")
	--go.set_parent("/camera", ".")	
	msg.post("@render:", "use_camera_projection")
	--go.set("/camera#camera", "orthographic_zoom", .3)

	self.sprSize = go.get("#sprite", "size")
	self.origin = go.get_position()
	self.velocity = vmath.vector3(0)
	self.ground_contact = nil
	self.correction = vmath.vector3()
	self.direction = 1

	self.states = {
		idle = idleState,
		run = runState,
		air = airState,
		jump = jumpState,
		land = landState
	}

	self.fsm = fsm.createMachine(self.states)
	self.fsm:changeState(self, "air")
end


------------------------------------
-- Input
------------------------------------
function on_input(self, action_id, action)
	self.fsm:input(self, action_id, action) -- Call to state machine
end


------------------------------------
-- Update
------------------------------------
function fixed_update(self, dt)	
	local position = go.get_position()
	-- 	local to = vmath.vector3(position.x, (position.y - self.sprSize.y * .5) - slopeDistance, position.z)
	-- 
	-- 	local toFront = vmath.vector3(position.x + slopeDistance, (position.y - self.sprSize.y * .5) - slopeDistance, position.z)
	-- 	local toBack = vmath.vector3(position.x - slopeDistance, (position.y - self.sprSize.y * .5) - slopeDistance, position.z)
	-- 
	-- 	msg.post("@render:", "draw_line", { start_point = position, end_point = toFront, color = vmath.vector4(1, 0, 0, 1) })
	-- 	msg.post("@render:", "draw_line", { start_point = position, end_point = toBack, color = vmath.vector4(0, 0, 1, 1) })		
	-- 	msg.post("@render:", "draw_line", { start_point = position, end_point = to, color = vmath.vector4(0, 1, 0, 1) })		
	-- 
	self.fsm:fixed_update(self, dt) -- Call to state machine

	local p = go.get_position("camera")
	go.set_position( vmath.vector3(position.x, position.y, p.z), "camera")
end


---------------------------------
-- Collision code used with 
-- Kinematic bodies. Gives better
--  control over Dynamic bodies
---------------------------------
-- https://defold.com/manuals/physics/#resolving-kinematic-collisions
local function handle_obstacle_contact(self, normal, distance)

	local comp = vmath.vector3()

	if distance > 0 then
		-- First, project the accumulated correction onto
		-- the penetration vector
		local proj = vmath.project(self.correction, normal * distance)
		if proj < 1 then
			-- Only care for projections that do not overshoot.		
			comp = ((distance - distance * proj) * normal)			
			go.set_position(go.get_position() + comp)
			-- Accumulate correction done
			self.correction = self.correction + comp
		end
	end

	-- Collided with a wall. Stop horizontal movement	
	if math.abs(normal.x) > 0.5 then
		--print(normal) 
		self.wall_contact = true
	end

	-- collided with the ground
	--if self.velocity.y < 0 then
	if normal.y > 0.5 then
		self.ground_contact = true
	end


	-- Collided with the head on object. Stop upward movement
	if normal.y < -0.7 then		
		if self.velocity.y < 0.0 then
			self.velocity.y = self.velocity.y * 2  -- Prevent sticking to moving platforms
		else
			self.velocity.y = 0		
		end
	end
end

---------------------------------
-- Message system
---------------------------------
function on_message(self, message_id, message, sender)

	if message_id == hash("contact_point_response") then
		-- check that the object is something we consider an obstacle
		if message.group == hash("ground") then
			--pprint(message)
			handle_obstacle_contact(self, message.normal, message.distance)
		end
	end
end


function final(self)
	self.fsm.purge(self)
	self.fsm = nil
end